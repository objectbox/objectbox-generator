// Code generated by ObjectBox; DO NOT EDIT.

#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "flatcc/flatcc.h"
#include "flatcc/flatcc_builder.h"
#include "objectbox.h"

/// Internal function used in other generated functions to put (write) explicitly typed objects.
static obx_id schema_obx_h_put_object(OBX_box* box, void* object,
                             bool (*to_flatbuffer)(flatcc_builder_t*, const void*, void**, size_t*), OBXPutMode mode);

/// Internal function used in other generated functions to get (read) explicitly typed objects.
static void* schema_obx_h_get_object(OBX_box* box, obx_id id, void* (*from_flatbuffer)(const void*, size_t));

/// Internal function used in other generated functions to get a vTable offset for a given field.
static flatbuffers_voffset_t schema_obx_h_fb_field_offset(flatbuffers_voffset_t vs, const flatbuffers_voffset_t* vt, size_t field);


/// Entity documentation is copied
/// into the generated output
typedef struct Typeful {
    obx_id id;
    int32_t int_;
    int8_t int8;
    int16_t int16;
    int32_t int32;
    int64_t int64;
    uint32_t uint;
    uint8_t uint8;
    uint16_t uint16;
    uint32_t uint32;
    uint64_t uint64;
    bool bool_;
    char* string;
    char** stringvector;
    size_t stringvector_len;
    int8_t byte;
    uint8_t ubyte;
    int8_t* bytevector;
    size_t bytevector_len;
    uint8_t* ubytevector;
    size_t ubytevector_len;
    float float32;
    double float64;
    float float_;
    float* floatvector;
    size_t floatvector_len;
    double double_;
    /// Relation to an entity declared later in the same file
    obx_id relId;
    
} Typeful;

enum Typeful_ {
    Typeful_ENTITY_ID = 1,
    Typeful_PROP_ID_id = 1,
    Typeful_PROP_ID_int_ = 2,
    Typeful_PROP_ID_int8 = 3,
    Typeful_PROP_ID_int16 = 4,
    Typeful_PROP_ID_int32 = 5,
    Typeful_PROP_ID_int64 = 6,
    Typeful_PROP_ID_uint = 7,
    Typeful_PROP_ID_uint8 = 8,
    Typeful_PROP_ID_uint16 = 9,
    Typeful_PROP_ID_uint32 = 10,
    Typeful_PROP_ID_uint64 = 11,
    Typeful_PROP_ID_bool_ = 12,
    Typeful_PROP_ID_string = 13,
    Typeful_PROP_ID_stringvector = 14,
    Typeful_PROP_ID_byte = 15,
    Typeful_PROP_ID_ubyte = 16,
    Typeful_PROP_ID_bytevector = 17,
    Typeful_PROP_ID_ubytevector = 18,
    Typeful_PROP_ID_float32 = 19,
    Typeful_PROP_ID_float64 = 20,
    Typeful_PROP_ID_float_ = 21,
    Typeful_PROP_ID_floatvector = 22,
    Typeful_PROP_ID_double_ = 23,
    Typeful_PROP_ID_relId = 24,
};

/// Write given object to the FlatBufferBuilder
static bool Typeful_to_flatbuffer(flatcc_builder_t* B, const Typeful* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling Typeful_free_pointers().
/// Thus, when calling this function multiple times on the same object, ensure to call Typeful_free_pointers() before subsequent calls to avoid leaks. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool Typeful_from_flatbuffer(const void* data, size_t size, Typeful* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling Typeful_free();
static Typeful* Typeful_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties, setting the freed pointers to NULL.  
static void Typeful_free_pointers(Typeful* object);

/// Free Typeful* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling Typeful_free_pointers() followed by free();
static void Typeful_free(Typeful* object);

typedef struct ns_Annotated {
    /// Objectbox requires an ID property.
    /// It is recognized automatically if it has a right name ("id") or needs to be annotated otherwise.
    obx_id identifier;
    char* fullName;
    int64_t time;
    obx_id relId;
    /// unique on string without index type implies HASH index
    char* unique;
    char* uniqueValue;
    char* uniqueHash;
    char* uniqueHash64;
    /// unique on string without index type implies HASH index
    int32_t uid;
    float* hnswVectorEuclidean;
    size_t hnswVectorEuclidean_len;
    float* hnswVectorCosine;
    size_t hnswVectorCosine_len;
    float* hnswVectorDot;
    size_t hnswVectorDot_len;
    float* hnswVectorDotNonNormalized;
    size_t hnswVectorDotNonNormalized_len;
    
} ns_Annotated;

enum ns_Annotated_ {
    ns_Annotated_ENTITY_ID = 2,
    ns_Annotated_PROP_ID_identifier = 1,
    ns_Annotated_PROP_ID_fullName = 2,
    ns_Annotated_PROP_ID_time = 3,
    ns_Annotated_PROP_ID_relId = 4,
    ns_Annotated_PROP_ID_unique = 5,
    ns_Annotated_PROP_ID_uniqueValue = 6,
    ns_Annotated_PROP_ID_uniqueHash = 7,
    ns_Annotated_PROP_ID_uniqueHash64 = 8,
    ns_Annotated_PROP_ID_uid = 9,
    ns_Annotated_PROP_ID_hnswVectorEuclidean = 10,
    ns_Annotated_PROP_ID_hnswVectorCosine = 11,
    ns_Annotated_PROP_ID_hnswVectorDot = 12,
    ns_Annotated_PROP_ID_hnswVectorDotNonNormalized = 13,
    ns_Annotated_REL_ID_typefuls = 1,
    ns_Annotated_REL_ID_m2m = 2,
};

/// Write given object to the FlatBufferBuilder
static bool ns_Annotated_to_flatbuffer(flatcc_builder_t* B, const ns_Annotated* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling ns_Annotated_free_pointers().
/// Thus, when calling this function multiple times on the same object, ensure to call ns_Annotated_free_pointers() before subsequent calls to avoid leaks. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool ns_Annotated_from_flatbuffer(const void* data, size_t size, ns_Annotated* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling ns_Annotated_free();
static ns_Annotated* ns_Annotated_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties, setting the freed pointers to NULL.  
static void ns_Annotated_free_pointers(ns_Annotated* object);

/// Free ns_Annotated* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling ns_Annotated_free_pointers() followed by free();
static void ns_Annotated_free(ns_Annotated* object);

typedef struct ns_TSDate {
    obx_id id;
    int64_t timestamp;
    
} ns_TSDate;

enum ns_TSDate_ {
    ns_TSDate_ENTITY_ID = 3,
    ns_TSDate_PROP_ID_id = 1,
    ns_TSDate_PROP_ID_timestamp = 2,
};

/// Write given object to the FlatBufferBuilder
static bool ns_TSDate_to_flatbuffer(flatcc_builder_t* B, const ns_TSDate* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling ns_TSDate_free_pointers().
/// Thus, when calling this function multiple times on the same object, ensure to call ns_TSDate_free_pointers() before subsequent calls to avoid leaks. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool ns_TSDate_from_flatbuffer(const void* data, size_t size, ns_TSDate* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling ns_TSDate_free();
static ns_TSDate* ns_TSDate_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties, setting the freed pointers to NULL.  
static void ns_TSDate_free_pointers(ns_TSDate* object);

/// Free ns_TSDate* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling ns_TSDate_free_pointers() followed by free();
static void ns_TSDate_free(ns_TSDate* object);

typedef struct ns_TSDateNano {
    obx_id id;
    int64_t timestamp;
    
} ns_TSDateNano;

enum ns_TSDateNano_ {
    ns_TSDateNano_ENTITY_ID = 4,
    ns_TSDateNano_PROP_ID_id = 1,
    ns_TSDateNano_PROP_ID_timestamp = 2,
};

/// Write given object to the FlatBufferBuilder
static bool ns_TSDateNano_to_flatbuffer(flatcc_builder_t* B, const ns_TSDateNano* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling ns_TSDateNano_free_pointers().
/// Thus, when calling this function multiple times on the same object, ensure to call ns_TSDateNano_free_pointers() before subsequent calls to avoid leaks. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool ns_TSDateNano_from_flatbuffer(const void* data, size_t size, ns_TSDateNano* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling ns_TSDateNano_free();
static ns_TSDateNano* ns_TSDateNano_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties, setting the freed pointers to NULL.  
static void ns_TSDateNano_free_pointers(ns_TSDateNano* object);

/// Free ns_TSDateNano* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling ns_TSDateNano_free_pointers() followed by free();
static void ns_TSDateNano_free(ns_TSDateNano* object);

static bool Typeful_to_flatbuffer(flatcc_builder_t* B, const Typeful* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    
    flatcc_builder_ref_t offset_string = !object->string ? 0 : flatcc_builder_create_string_str(B, object->string);
    flatcc_builder_ref_t offset_stringvector = 0;
    if (object->stringvector) {
        flatcc_builder_start_offset_vector(B);
        for (size_t i = 0; i < object->stringvector_len; i++) {
            flatcc_builder_ref_t ref = !object->stringvector[i] ? 0 : flatcc_builder_create_string_str(B, object->stringvector[i]);
            if (ref) flatcc_builder_offset_vector_push(B, ref);
        }
        offset_stringvector = flatcc_builder_end_offset_vector(B);
    }
    flatcc_builder_ref_t offset_bytevector = !object->bytevector ? 0 : flatcc_builder_create_vector(B, object->bytevector, object->bytevector_len, sizeof(int8_t), sizeof(int8_t), FLATBUFFERS_COUNT_MAX(sizeof(int8_t)));
    flatcc_builder_ref_t offset_ubytevector = !object->ubytevector ? 0 : flatcc_builder_create_vector(B, object->ubytevector, object->ubytevector_len, sizeof(uint8_t), sizeof(uint8_t), FLATBUFFERS_COUNT_MAX(sizeof(uint8_t)));
    flatcc_builder_ref_t offset_floatvector = !object->floatvector ? 0 : flatcc_builder_create_vector(B, object->floatvector, object->floatvector_len, sizeof(float), sizeof(float), FLATBUFFERS_COUNT_MAX(sizeof(float)));

    if (flatcc_builder_start_table(B, 24) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    {
        if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->id);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 1, 4, 4))) return false;
        flatbuffers_int32_write_to_pe(p, object->int_);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 2, 1, 1))) return false;
        flatbuffers_int8_write_to_pe(p, object->int8);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 3, 2, 2))) return false;
        flatbuffers_int16_write_to_pe(p, object->int16);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 4, 4, 4))) return false;
        flatbuffers_int32_write_to_pe(p, object->int32);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 5, 8, 8))) return false;
        flatbuffers_int64_write_to_pe(p, object->int64);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 6, 4, 4))) return false;
        flatbuffers_uint32_write_to_pe(p, object->uint);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 7, 1, 1))) return false;
        flatbuffers_uint8_write_to_pe(p, object->uint8);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 8, 2, 2))) return false;
        flatbuffers_uint16_write_to_pe(p, object->uint16);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 9, 4, 4))) return false;
        flatbuffers_uint32_write_to_pe(p, object->uint32);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 10, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->uint64);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 11, 1, 1))) return false;
        flatbuffers_bool_write_to_pe(p, object->bool_);
    }
    
    if (offset_string) {
        if (!(_p = flatcc_builder_table_add_offset(B, 12))) return false;
        *_p = offset_string;
    }
    
    if (offset_stringvector) {
        if (!(_p = flatcc_builder_table_add_offset(B, 13))) return false;
        *_p = offset_stringvector;
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 14, 1, 1))) return false;
        flatbuffers_int8_write_to_pe(p, object->byte);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 15, 1, 1))) return false;
        flatbuffers_uint8_write_to_pe(p, object->ubyte);
    }
    
    if (offset_bytevector) {
        if (!(_p = flatcc_builder_table_add_offset(B, 16))) return false;
        *_p = offset_bytevector;
    }
    
    if (offset_ubytevector) {
        if (!(_p = flatcc_builder_table_add_offset(B, 17))) return false;
        *_p = offset_ubytevector;
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 18, 4, 4))) return false;
        flatbuffers_float_write_to_pe(p, object->float32);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 19, 8, 8))) return false;
        flatbuffers_double_write_to_pe(p, object->float64);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 20, 4, 4))) return false;
        flatbuffers_float_write_to_pe(p, object->float_);
    }
    
    if (offset_floatvector) {
        if (!(_p = flatcc_builder_table_add_offset(B, 21))) return false;
        *_p = offset_floatvector;
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 22, 8, 8))) return false;
        flatbuffers_double_write_to_pe(p, object->double_);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 23, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->relId);
    }
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool Typeful_from_flatbuffer(const void* data, size_t size, Typeful* out_object) {
    assert(data);
    assert(size > 0);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    const flatbuffers_voffset_t* vt = (const flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    // reset so that dangling pointers are freed properly on malloc() failures
#ifdef __cplusplus
    *out_object = {};
#else
    *out_object = (Typeful){0};
#endif
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 0))) {
        out_object->id = flatbuffers_uint64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 1))) {
        out_object->int_ = flatbuffers_int32_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 2))) {
        out_object->int8 = flatbuffers_int8_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 3))) {
        out_object->int16 = flatbuffers_int16_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 4))) {
        out_object->int32 = flatbuffers_int32_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 5))) {
        out_object->int64 = flatbuffers_int64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 6))) {
        out_object->uint = flatbuffers_uint32_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 7))) {
        out_object->uint8 = flatbuffers_uint8_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 8))) {
        out_object->uint16 = flatbuffers_uint16_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 9))) {
        out_object->uint32 = flatbuffers_uint32_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 10))) {
        out_object->uint64 = flatbuffers_uint64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 11))) {
        out_object->bool_ = flatbuffers_bool_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 12))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->string = (char*) malloc((len+1) * sizeof(char));
        if (out_object->string == NULL) {
            Typeful_free_pointers(out_object);
            return false;
        }
        memcpy((void*)out_object->string, (const void*)val, len+1);
        
    } else {
        out_object->string = NULL;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 13))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->stringvector = (char**) malloc(len * sizeof(char*));
        if (out_object->stringvector == NULL) {
            Typeful_free_pointers(out_object);
            return false;
        }
        out_object->stringvector_len = len;
        for (size_t i = 0; i < len; i++, val++) {
            const uint8_t* str = (const uint8_t*) val + (size_t)__flatbuffers_uoffset_read_from_pe(val) + sizeof(val[0]);
            out_object->stringvector[i] = (char*) malloc((strlen((const char*)str) + 1) * sizeof(char));
            if (out_object->stringvector[i] == NULL) {
                out_object->stringvector_len = i; // only free() indexes before the current "i"
                Typeful_free_pointers(out_object);
                return false;
            }
            strcpy((char*)out_object->stringvector[i], (const char*)str);
        }
    } else {
        out_object->stringvector = NULL;
        out_object->stringvector_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 14))) {
        out_object->byte = flatbuffers_int8_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 15))) {
        out_object->ubyte = flatbuffers_uint8_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 16))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->bytevector = (int8_t*) malloc(len * sizeof(int8_t));
        if (out_object->bytevector == NULL) {
            Typeful_free_pointers(out_object);
            return false;
        }
        out_object->bytevector_len = len;
        memcpy((void*)out_object->bytevector, (const void*)val, len);
        
    } else {
        out_object->bytevector = NULL;
        out_object->bytevector_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 17))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->ubytevector = (uint8_t*) malloc(len * sizeof(uint8_t));
        if (out_object->ubytevector == NULL) {
            Typeful_free_pointers(out_object);
            return false;
        }
        out_object->ubytevector_len = len;
        memcpy((void*)out_object->ubytevector, (const void*)val, len);
        
    } else {
        out_object->ubytevector = NULL;
        out_object->ubytevector_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 18))) {
        out_object->float32 = flatbuffers_float_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 19))) {
        out_object->float64 = flatbuffers_double_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 20))) {
        out_object->float_ = flatbuffers_float_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 21))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->floatvector = (float*) malloc(len * sizeof(float));
        if (out_object->floatvector == NULL) {
            Typeful_free_pointers(out_object);
            return false;
        }
        out_object->floatvector_len = len;
        memcpy((void*)out_object->floatvector, (const void*)val, sizeof(float)*len);
        
    } else {
        out_object->floatvector = NULL;
        out_object->floatvector_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 22))) {
        out_object->double_ = flatbuffers_double_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 23))) {
        out_object->relId = flatbuffers_uint64_read_from_pe(table + offset);
    }
    return true;
}

static Typeful* Typeful_new_from_flatbuffer(const void* data, size_t size) {
    Typeful* object = (Typeful*) malloc(sizeof(Typeful));
    if (object) {
        if (!Typeful_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void Typeful_free_pointers(Typeful* object) {
    if (object == NULL) return;
    if (object->string) {
        free(object->string);
        object->string = NULL;
    }
    if (object->stringvector) {
        for (size_t i = 0; i < object->stringvector_len; i++) {
            if (object->stringvector[i]) free(object->stringvector[i]);
        }
        free(object->stringvector);
        object->stringvector = NULL;
        object->stringvector_len = 0;
    } else {
        assert(object->stringvector_len == 0);
    }
    if (object->bytevector) {
        free(object->bytevector);
        object->bytevector = NULL;
        object->bytevector_len = 0;
    } else {
        assert(object->bytevector_len == 0);
    }
    if (object->ubytevector) {
        free(object->ubytevector);
        object->ubytevector = NULL;
        object->ubytevector_len = 0;
    } else {
        assert(object->ubytevector_len == 0);
    }
    if (object->floatvector) {
        free(object->floatvector);
        object->floatvector = NULL;
        object->floatvector_len = 0;
    } else {
        assert(object->floatvector_len == 0);
    }
    
}

static void Typeful_free(Typeful* object) {
    Typeful_free_pointers(object);
    free(object);
}

/// Insert or update the given object in the database.
/// @param object (in & out) will be updated with a newly inserted ID if the one specified previously was zero. If an ID 
/// was already specified (non-zero), it will remain unchanged.
/// @return object ID from the object param (see object param docs) or a zero on error. If a zero was returned, you can
/// check obx_last_error_*() to get the error details. In an unlikely event that those functions return no error
/// code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
static obx_id Typeful_put(OBX_box* box, Typeful* object) {
    obx_id id = schema_obx_h_put_object(box, object,
                               (bool (*)(flatcc_builder_t*, const void*, void**, size_t*)) Typeful_to_flatbuffer,
                               OBXPutMode_PUT);
    if (id != 0) {
        object->id = id;  // update the ID property on new objects for convenience
    }
    return id;
}

/// Read an object from the database, returning a pointer.
/// @return an object pointer or NULL if an object with the given ID doesn't exist or any other error occurred. You can
/// check obx_last_error_*() if NULL is returned to get the error details. In an unlikely event that those functions
/// return no error code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
/// @note: The returned object must be freed after use by calling Typeful_free();
static Typeful* Typeful_get(OBX_box* box, obx_id id) {
    return (Typeful*) schema_obx_h_get_object(box, id, (void* (*) (const void*, size_t)) Typeful_new_from_flatbuffer);
}

static bool ns_Annotated_to_flatbuffer(flatcc_builder_t* B, const ns_Annotated* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    
    flatcc_builder_ref_t offset_fullName = !object->fullName ? 0 : flatcc_builder_create_string_str(B, object->fullName);
    flatcc_builder_ref_t offset_unique = !object->unique ? 0 : flatcc_builder_create_string_str(B, object->unique);
    flatcc_builder_ref_t offset_uniqueValue = !object->uniqueValue ? 0 : flatcc_builder_create_string_str(B, object->uniqueValue);
    flatcc_builder_ref_t offset_uniqueHash = !object->uniqueHash ? 0 : flatcc_builder_create_string_str(B, object->uniqueHash);
    flatcc_builder_ref_t offset_uniqueHash64 = !object->uniqueHash64 ? 0 : flatcc_builder_create_string_str(B, object->uniqueHash64);
    flatcc_builder_ref_t offset_hnswVectorEuclidean = !object->hnswVectorEuclidean ? 0 : flatcc_builder_create_vector(B, object->hnswVectorEuclidean, object->hnswVectorEuclidean_len, sizeof(float), sizeof(float), FLATBUFFERS_COUNT_MAX(sizeof(float)));
    flatcc_builder_ref_t offset_hnswVectorCosine = !object->hnswVectorCosine ? 0 : flatcc_builder_create_vector(B, object->hnswVectorCosine, object->hnswVectorCosine_len, sizeof(float), sizeof(float), FLATBUFFERS_COUNT_MAX(sizeof(float)));
    flatcc_builder_ref_t offset_hnswVectorDot = !object->hnswVectorDot ? 0 : flatcc_builder_create_vector(B, object->hnswVectorDot, object->hnswVectorDot_len, sizeof(float), sizeof(float), FLATBUFFERS_COUNT_MAX(sizeof(float)));
    flatcc_builder_ref_t offset_hnswVectorDotNonNormalized = !object->hnswVectorDotNonNormalized ? 0 : flatcc_builder_create_vector(B, object->hnswVectorDotNonNormalized, object->hnswVectorDotNonNormalized_len, sizeof(float), sizeof(float), FLATBUFFERS_COUNT_MAX(sizeof(float)));

    if (flatcc_builder_start_table(B, 13) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    {
        if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->identifier);
    }
    
    if (offset_fullName) {
        if (!(_p = flatcc_builder_table_add_offset(B, 1))) return false;
        *_p = offset_fullName;
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 2, 8, 8))) return false;
        flatbuffers_int64_write_to_pe(p, object->time);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 3, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->relId);
    }
    
    if (offset_unique) {
        if (!(_p = flatcc_builder_table_add_offset(B, 4))) return false;
        *_p = offset_unique;
    }
    
    if (offset_uniqueValue) {
        if (!(_p = flatcc_builder_table_add_offset(B, 5))) return false;
        *_p = offset_uniqueValue;
    }
    
    if (offset_uniqueHash) {
        if (!(_p = flatcc_builder_table_add_offset(B, 6))) return false;
        *_p = offset_uniqueHash;
    }
    
    if (offset_uniqueHash64) {
        if (!(_p = flatcc_builder_table_add_offset(B, 7))) return false;
        *_p = offset_uniqueHash64;
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 8, 4, 4))) return false;
        flatbuffers_int32_write_to_pe(p, object->uid);
    }
    
    if (offset_hnswVectorEuclidean) {
        if (!(_p = flatcc_builder_table_add_offset(B, 9))) return false;
        *_p = offset_hnswVectorEuclidean;
    }
    
    if (offset_hnswVectorCosine) {
        if (!(_p = flatcc_builder_table_add_offset(B, 10))) return false;
        *_p = offset_hnswVectorCosine;
    }
    
    if (offset_hnswVectorDot) {
        if (!(_p = flatcc_builder_table_add_offset(B, 11))) return false;
        *_p = offset_hnswVectorDot;
    }
    
    if (offset_hnswVectorDotNonNormalized) {
        if (!(_p = flatcc_builder_table_add_offset(B, 12))) return false;
        *_p = offset_hnswVectorDotNonNormalized;
    }
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool ns_Annotated_from_flatbuffer(const void* data, size_t size, ns_Annotated* out_object) {
    assert(data);
    assert(size > 0);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    const flatbuffers_voffset_t* vt = (const flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    // reset so that dangling pointers are freed properly on malloc() failures
#ifdef __cplusplus
    *out_object = {};
#else
    *out_object = (ns_Annotated){0};
#endif
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 0))) {
        out_object->identifier = flatbuffers_uint64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 1))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->fullName = (char*) malloc((len+1) * sizeof(char));
        if (out_object->fullName == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        memcpy((void*)out_object->fullName, (const void*)val, len+1);
        
    } else {
        out_object->fullName = NULL;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 2))) {
        out_object->time = flatbuffers_int64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 3))) {
        out_object->relId = flatbuffers_uint64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 4))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->unique = (char*) malloc((len+1) * sizeof(char));
        if (out_object->unique == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        memcpy((void*)out_object->unique, (const void*)val, len+1);
        
    } else {
        out_object->unique = NULL;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 5))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->uniqueValue = (char*) malloc((len+1) * sizeof(char));
        if (out_object->uniqueValue == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        memcpy((void*)out_object->uniqueValue, (const void*)val, len+1);
        
    } else {
        out_object->uniqueValue = NULL;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 6))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->uniqueHash = (char*) malloc((len+1) * sizeof(char));
        if (out_object->uniqueHash == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        memcpy((void*)out_object->uniqueHash, (const void*)val, len+1);
        
    } else {
        out_object->uniqueHash = NULL;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 7))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->uniqueHash64 = (char*) malloc((len+1) * sizeof(char));
        if (out_object->uniqueHash64 == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        memcpy((void*)out_object->uniqueHash64, (const void*)val, len+1);
        
    } else {
        out_object->uniqueHash64 = NULL;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 8))) {
        out_object->uid = flatbuffers_int32_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 9))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->hnswVectorEuclidean = (float*) malloc(len * sizeof(float));
        if (out_object->hnswVectorEuclidean == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        out_object->hnswVectorEuclidean_len = len;
        memcpy((void*)out_object->hnswVectorEuclidean, (const void*)val, sizeof(float)*len);
        
    } else {
        out_object->hnswVectorEuclidean = NULL;
        out_object->hnswVectorEuclidean_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 10))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->hnswVectorCosine = (float*) malloc(len * sizeof(float));
        if (out_object->hnswVectorCosine == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        out_object->hnswVectorCosine_len = len;
        memcpy((void*)out_object->hnswVectorCosine, (const void*)val, sizeof(float)*len);
        
    } else {
        out_object->hnswVectorCosine = NULL;
        out_object->hnswVectorCosine_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 11))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->hnswVectorDot = (float*) malloc(len * sizeof(float));
        if (out_object->hnswVectorDot == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        out_object->hnswVectorDot_len = len;
        memcpy((void*)out_object->hnswVectorDot, (const void*)val, sizeof(float)*len);
        
    } else {
        out_object->hnswVectorDot = NULL;
        out_object->hnswVectorDot_len = 0;
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 12))) {
        val = (const flatbuffers_uoffset_t*)(table + offset + sizeof(flatbuffers_uoffset_t) + __flatbuffers_uoffset_read_from_pe(table + offset));
        len = (size_t) __flatbuffers_uoffset_read_from_pe(val - 1);
        out_object->hnswVectorDotNonNormalized = (float*) malloc(len * sizeof(float));
        if (out_object->hnswVectorDotNonNormalized == NULL) {
            ns_Annotated_free_pointers(out_object);
            return false;
        }
        out_object->hnswVectorDotNonNormalized_len = len;
        memcpy((void*)out_object->hnswVectorDotNonNormalized, (const void*)val, sizeof(float)*len);
        
    } else {
        out_object->hnswVectorDotNonNormalized = NULL;
        out_object->hnswVectorDotNonNormalized_len = 0;
    }
    return true;
}

static ns_Annotated* ns_Annotated_new_from_flatbuffer(const void* data, size_t size) {
    ns_Annotated* object = (ns_Annotated*) malloc(sizeof(ns_Annotated));
    if (object) {
        if (!ns_Annotated_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void ns_Annotated_free_pointers(ns_Annotated* object) {
    if (object == NULL) return;
    if (object->fullName) {
        free(object->fullName);
        object->fullName = NULL;
    }
    if (object->unique) {
        free(object->unique);
        object->unique = NULL;
    }
    if (object->uniqueValue) {
        free(object->uniqueValue);
        object->uniqueValue = NULL;
    }
    if (object->uniqueHash) {
        free(object->uniqueHash);
        object->uniqueHash = NULL;
    }
    if (object->uniqueHash64) {
        free(object->uniqueHash64);
        object->uniqueHash64 = NULL;
    }
    if (object->hnswVectorEuclidean) {
        free(object->hnswVectorEuclidean);
        object->hnswVectorEuclidean = NULL;
        object->hnswVectorEuclidean_len = 0;
    } else {
        assert(object->hnswVectorEuclidean_len == 0);
    }
    if (object->hnswVectorCosine) {
        free(object->hnswVectorCosine);
        object->hnswVectorCosine = NULL;
        object->hnswVectorCosine_len = 0;
    } else {
        assert(object->hnswVectorCosine_len == 0);
    }
    if (object->hnswVectorDot) {
        free(object->hnswVectorDot);
        object->hnswVectorDot = NULL;
        object->hnswVectorDot_len = 0;
    } else {
        assert(object->hnswVectorDot_len == 0);
    }
    if (object->hnswVectorDotNonNormalized) {
        free(object->hnswVectorDotNonNormalized);
        object->hnswVectorDotNonNormalized = NULL;
        object->hnswVectorDotNonNormalized_len = 0;
    } else {
        assert(object->hnswVectorDotNonNormalized_len == 0);
    }
    
}

static void ns_Annotated_free(ns_Annotated* object) {
    ns_Annotated_free_pointers(object);
    free(object);
}

/// Insert or update the given object in the database.
/// @param object (in & out) will be updated with a newly inserted ID if the one specified previously was zero. If an ID 
/// was already specified (non-zero), it will remain unchanged.
/// @return object ID from the object param (see object param docs) or a zero on error. If a zero was returned, you can
/// check obx_last_error_*() to get the error details. In an unlikely event that those functions return no error
/// code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
static obx_id ns_Annotated_put(OBX_box* box, ns_Annotated* object) {
    obx_id id = schema_obx_h_put_object(box, object,
                               (bool (*)(flatcc_builder_t*, const void*, void**, size_t*)) ns_Annotated_to_flatbuffer,
                               OBXPutMode_PUT);
    if (id != 0) {
        object->identifier = id;  // update the ID property on new objects for convenience
    }
    return id;
}

/// Read an object from the database, returning a pointer.
/// @return an object pointer or NULL if an object with the given ID doesn't exist or any other error occurred. You can
/// check obx_last_error_*() if NULL is returned to get the error details. In an unlikely event that those functions
/// return no error code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
/// @note: The returned object must be freed after use by calling ns_Annotated_free();
static ns_Annotated* ns_Annotated_get(OBX_box* box, obx_id id) {
    return (ns_Annotated*) schema_obx_h_get_object(box, id, (void* (*) (const void*, size_t)) ns_Annotated_new_from_flatbuffer);
}

static bool ns_TSDate_to_flatbuffer(flatcc_builder_t* B, const ns_TSDate* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    

    if (flatcc_builder_start_table(B, 2) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    {
        if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->id);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 1, 8, 8))) return false;
        flatbuffers_int64_write_to_pe(p, object->timestamp);
    }
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool ns_TSDate_from_flatbuffer(const void* data, size_t size, ns_TSDate* out_object) {
    assert(data);
    assert(size > 0);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    const flatbuffers_voffset_t* vt = (const flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    // reset so that dangling pointers are freed properly on malloc() failures
#ifdef __cplusplus
    *out_object = {};
#else
    *out_object = (ns_TSDate){0};
#endif
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 0))) {
        out_object->id = flatbuffers_uint64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 1))) {
        out_object->timestamp = flatbuffers_int64_read_from_pe(table + offset);
    }
    return true;
}

static ns_TSDate* ns_TSDate_new_from_flatbuffer(const void* data, size_t size) {
    ns_TSDate* object = (ns_TSDate*) malloc(sizeof(ns_TSDate));
    if (object) {
        if (!ns_TSDate_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void ns_TSDate_free_pointers(ns_TSDate* object) {
    if (object == NULL) return;
    
}

static void ns_TSDate_free(ns_TSDate* object) {
    ns_TSDate_free_pointers(object);
    free(object);
}

/// Insert or update the given object in the database.
/// @param object (in & out) will be updated with a newly inserted ID if the one specified previously was zero. If an ID 
/// was already specified (non-zero), it will remain unchanged.
/// @return object ID from the object param (see object param docs) or a zero on error. If a zero was returned, you can
/// check obx_last_error_*() to get the error details. In an unlikely event that those functions return no error
/// code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
static obx_id ns_TSDate_put(OBX_box* box, ns_TSDate* object) {
    obx_id id = schema_obx_h_put_object(box, object,
                               (bool (*)(flatcc_builder_t*, const void*, void**, size_t*)) ns_TSDate_to_flatbuffer,
                               OBXPutMode_PUT);
    if (id != 0) {
        object->id = id;  // update the ID property on new objects for convenience
    }
    return id;
}

/// Read an object from the database, returning a pointer.
/// @return an object pointer or NULL if an object with the given ID doesn't exist or any other error occurred. You can
/// check obx_last_error_*() if NULL is returned to get the error details. In an unlikely event that those functions
/// return no error code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
/// @note: The returned object must be freed after use by calling ns_TSDate_free();
static ns_TSDate* ns_TSDate_get(OBX_box* box, obx_id id) {
    return (ns_TSDate*) schema_obx_h_get_object(box, id, (void* (*) (const void*, size_t)) ns_TSDate_new_from_flatbuffer);
}

static bool ns_TSDateNano_to_flatbuffer(flatcc_builder_t* B, const ns_TSDateNano* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    

    if (flatcc_builder_start_table(B, 2) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    {
        if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
        flatbuffers_uint64_write_to_pe(p, object->id);
    }
    
    {
        if (!(p = flatcc_builder_table_add(B, 1, 8, 8))) return false;
        flatbuffers_int64_write_to_pe(p, object->timestamp);
    }
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool ns_TSDateNano_from_flatbuffer(const void* data, size_t size, ns_TSDateNano* out_object) {
    assert(data);
    assert(size > 0);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    const flatbuffers_voffset_t* vt = (const flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    // reset so that dangling pointers are freed properly on malloc() failures
#ifdef __cplusplus
    *out_object = {};
#else
    *out_object = (ns_TSDateNano){0};
#endif
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 0))) {
        out_object->id = flatbuffers_uint64_read_from_pe(table + offset);
    }
    if ((offset = schema_obx_h_fb_field_offset(vs, vt, 1))) {
        out_object->timestamp = flatbuffers_int64_read_from_pe(table + offset);
    }
    return true;
}

static ns_TSDateNano* ns_TSDateNano_new_from_flatbuffer(const void* data, size_t size) {
    ns_TSDateNano* object = (ns_TSDateNano*) malloc(sizeof(ns_TSDateNano));
    if (object) {
        if (!ns_TSDateNano_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void ns_TSDateNano_free_pointers(ns_TSDateNano* object) {
    if (object == NULL) return;
    
}

static void ns_TSDateNano_free(ns_TSDateNano* object) {
    ns_TSDateNano_free_pointers(object);
    free(object);
}

/// Insert or update the given object in the database.
/// @param object (in & out) will be updated with a newly inserted ID if the one specified previously was zero. If an ID 
/// was already specified (non-zero), it will remain unchanged.
/// @return object ID from the object param (see object param docs) or a zero on error. If a zero was returned, you can
/// check obx_last_error_*() to get the error details. In an unlikely event that those functions return no error
/// code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
static obx_id ns_TSDateNano_put(OBX_box* box, ns_TSDateNano* object) {
    obx_id id = schema_obx_h_put_object(box, object,
                               (bool (*)(flatcc_builder_t*, const void*, void**, size_t*)) ns_TSDateNano_to_flatbuffer,
                               OBXPutMode_PUT);
    if (id != 0) {
        object->id = id;  // update the ID property on new objects for convenience
    }
    return id;
}

/// Read an object from the database, returning a pointer.
/// @return an object pointer or NULL if an object with the given ID doesn't exist or any other error occurred. You can
/// check obx_last_error_*() if NULL is returned to get the error details. In an unlikely event that those functions
/// return no error code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
/// @note: The returned object must be freed after use by calling ns_TSDateNano_free();
static ns_TSDateNano* ns_TSDateNano_get(OBX_box* box, obx_id id) {
    return (ns_TSDateNano*) schema_obx_h_get_object(box, id, (void* (*) (const void*, size_t)) ns_TSDateNano_new_from_flatbuffer);
}

static obx_id schema_obx_h_put_object(OBX_box* box, void* object,
                             bool (*to_flatbuffer)(flatcc_builder_t*, const void*, void**, size_t*), OBXPutMode mode) {
    flatcc_builder_t builder;
    flatcc_builder_init(&builder);

    obx_id id = 0;
    size_t size = 0;
    void* buffer = NULL;
    if (!to_flatbuffer(&builder, object, &buffer, &size)) {
        obx_last_error_set(OBX_ERROR_STD_OTHER, 0, "FlatBuffer serialization failed");
    } else {
        id = obx_box_put_object4(box, buffer, size, mode);  // 0 on error
    }

    flatcc_builder_clear(&builder);
    if (buffer) flatcc_builder_aligned_free(buffer);

    return id;
}

static void* schema_obx_h_get_object(OBX_box* box, obx_id id, void* (*from_flatbuffer)(const void*, size_t)) {
    // We need an explicit TX - read data lifecycle is bound to the open TX.
    OBX_txn* tx = obx_txn_read(obx_box_store(box));
    if (!tx) return NULL;

    void* result = NULL;
    const void* data;
    size_t size;
    if (obx_box_get(box, id, &data, &size) == OBX_SUCCESS) {
        result = from_flatbuffer(data, size);
        if (result == NULL) {
            obx_last_error_set(OBX_ERROR_STD_OTHER, 0, "FlatBuffer deserialization failed");
        }
    }

    obx_txn_close(tx);
    return result;
}

static flatbuffers_voffset_t schema_obx_h_fb_field_offset(flatbuffers_voffset_t vs, const flatbuffers_voffset_t* vt, size_t field) {
    return (vs < sizeof(vt[0]) * (field + 3)) ? 0 : __flatbuffers_voffset_read_from_pe(vt + field + 2);
}
